/****************************************************************************
 *
 * CRI Middleware SDK
 *
 * Copyright (c) 2008 CRI Middleware, Inc. All rights reserved.
 *
 * Use, modification and distribution are subject to the CRI Script Software
 * License, Version 1.0(see accompanying file "CriScript_License_1_0.txt" or
 * copy at www.criscript.com/trac/wiki/CRI%20Script%20Software%20License%201.0 ).
 *
 *
 * Library  : CRIScript
 * Module   : cil definitions
 * File     : cilCodeGen.h
 * Date     : 
 * Version  : 
 *
 ****************************************************************************/
#pragma once

#include "iCodeGen.h"
#include "cilOpcode.h"
#include "cilBuiltinObject.h"
#include "lexer.h"
#include "error.h"

using namespace std;

/*EN
 * \brief cri namespace
 * \ingroup MDL_LIB_GLOBAL
 * \par
 * This namespace includes constants/class for the CRI Script library and functions affecting all of the CRI Script library.
 */
namespace cri {

/***************************************************************************
 *      Constatns
 ***************************************************************************/
/*EN Max number of labels in the symbol data*/
const int32_t MAX_NUM_LABELS = 0xffff;

/***************************************************************************
 *      Definitions
 ***************************************************************************/
typedef int32_t (*PEEPHOLEOPTIMIZERCALLBACK)(ILFRAGMENT::iterator itIn, ILFRAGMENT& vecOut);

/***************************************************************************
 *      Structures
 ***************************************************************************/
/*EN
 Structure defining type constraint information
*/
struct TYPECONSTRAINT_INFO {
	wchar_t* name;				/*EN< Fully Qualified Name of a symbol*/
	OPERAND_TYPE_FLAG type;		/*EN< Constraint Type*/
};

/*EN
 Structure defining branch target information
*/
struct BRANCH_TARGET_INFO {
	int32_t iExceptionHandlerNestLevel;	/*EN< A nesting level of exception handling caluses*/
};

/***************************************************************************
 *      Classes
 ***************************************************************************/
	//---------------------------------------------------------------------------
	// Code gen interface, derived from ICodeGen
	//---------------------------------------------------------------------------
	/*EN
	 \brief Code generation interface. Inherits ICodeGen.
	 \ingroup MDL_LIB_COMPILER
	 \par Basic class for a byte code stream generation.
	 Usually the user don't have to care the interface since the interface is used via CParser interface
	*/
	class CCilCodeGen : public ICodeGen
	{
	public:
		CCilCodeGen();				/*EN< ctor */
		virtual ~CCilCodeGen();		/*EN< dtor */
		bool init();				/*EN< Initializes the parser state */
		bool terminate();			/*EN< Terminates the parser */
		bool link ();				/*EN< Performs a linkage process */
		bool verify ();				/*EN< Verifies generated byte code stream */

		void setInterfaces( CParser* pParser, CLexer* pLex, CErrorPool * pError );
									/*EN< Sets misc interfaces to the parser
									\param pParser Pointer to a parser interface
									\param pLex Pointer to a lexer interface
									\param pError Pointer to an error pool interface
									*/

		//---------------------------------------------------------------------------
		//Initialize built in objects defined in JScript spec
		//---------------------------------------------------------------------------
		bool initializeBuiltInObjects();
									/*EN< Initializes built in object settings
									Built-in object initialization should be done prior to start compilation process.
									*/

		/*EN Registers built-in object name to the code generator
		\param strQualifiedName Qualified name of the object. A scope name is delimitted by '.'
		\return RID of the object registerred
		*/
		RID registerBuiltinObject( const wstring& strQualifiedName );

		/*EN Registers built-in method name to the code generator.
		\param strQualifiedName Qualified name of the method. A scope name is delimitted by '.'
		\param methodType A type of the method to be registered
		\param ridParam RID of a parameter list for the method
		\return RID of the method registerred.
		*/
		RID registerBuiltinMethod( const wstring& strQualifiedName,
									const METHOD_TYPE methodType,
									const RID_BUILTIN_PARAM ridParam );

		//---------------------------------------------------------------------------
		//Functions to retrieve parsed result
		//---------------------------------------------------------------------------
		/*EN Retrieves compiled IL stream
		\return vector of IL stream
		*/
		vector<uint8_t>& getILPool() { return m_ILResolvedPool.ILPool; }

		/*EN Retrieves symbol information map
		\return map of the symbol information
		note that symbol information format would be changed in future for simplisity and better debugger support.
		*/
		hash_map<wstring, CG_SYMBOL_INFORMATION>& getSymbolInformation() { return  m_SymbolInfoPool; }

		/*EN Retrieves meta data of the compiled script.
		\return meta data structure
		note that meta data format would be changed in future for simplisity and better debugger support.
		*/
		CMetaData& getMetaData() { return m_MetaData; }

		//---------------------------------------------------------
		//Codegen management
		//---------------------------------------------------------
		void setTargetEndianness( TARGET_ENDIANNESS );
									/*EN< Sets 'target' endianess setting.
									\attention Current platform's endianness setting is determined automatically.
									*/
		TARGET_ENDIANNESS getTargetEndianness();
									/*EN< gets 'target' endianess setting.
									*/
		TARGET_ENDIANNESS getCurrentEndianness();
									/*EN< gets 'current' platform's endianess setting.
									CRIScript can work for cross platform development
									so the endianness of current platform and target platform can differ.
									*/

		//---------------------------------------------------------
		//Multipass compilation control
		//---------------------------------------------------------

		/*EN Retrieves current multi pass compilation setting
		\return true if the compiler is set as multipass compilation, otherwise single pass.
		\attention Single pass compilation support would be removed.
		*/
		bool isMultiPasses();

		/*EN Sets multipass compilation setting.
		\attention Single pass compilation support would be removed.
		*/
		void setMultiPasses( bool b);

		//---------------------------------------------------------------------------
		// Constant pool
		//---------------------------------------------------------------------------
		CCgNodeData* literalConstant( const wchar_t* string,
								 const uint32_t iFileId = 0,
								 const uint32_t iLineNumber = 0,
								 const uint32_t iColumn = 0 );
		CCgNodeData* integerConstant( const int64_t value,
								 const uint32_t iFileId = 0,
								 const uint32_t iLineNumber = 0,
								 const uint32_t iColumn = 0 );
		CCgNodeData* booleanConstant( const bool value,
								 const uint32_t iFileId = 0,
								 const uint32_t iLineNumber = 0,
								 const uint32_t iColumn = 0 );
		CCgNodeData* floatConstant( const double value,
								 const uint32_t iFileId = 0,
								 const uint32_t iLineNumber = 0,
								 const uint32_t iColumn = 0 );
		CCgNodeData* identifier( const wchar_t* string,
								 const uint32_t iFileId = 0,
								 const uint32_t iLineNumber = 0,
								 const uint32_t iColumn = 0 );
		CCgNodeData* regexLiteral( const wchar_t* string,
								 const uint32_t iFileId = 0,
								 const uint32_t iLineNumber = 0,
								 const uint32_t iColumn = 0 );

		//---------------------------------------------------------------------------
		//Create and parse node tree
		//---------------------------------------------------------------------------
		CCgNodeData* makeFormulaNode(	CG_OPERATIONTYPE iOperation,
									CCgNodeData* lhs,
									CCgNodeData* rhs,
									bool bBlockTraverseLeft = false,
									bool bBlockTraverseRight = false );
		CCgNodeData* makeNode(		CG_NODE_TYPE NodeType,
									CG_OPERATIONTYPE iOperation = (CG_OPERATIONTYPE)0,
									CCgNodeData* lhs = NULL,
									CCgNodeData* rhs = NULL,
									CCgNodeData* siblingNode = NULL,
									CCgNodeData* initialNode = NULL,
									CCgNodeData* statementNode = NULL,
									CCgNodeData* conditionNode = NULL,
									CCgNodeData* argumentlistNode = NULL
									);
		CCgNodeData* duplicateNode( CCgNodeData* srcNode );					//Duplicate original node
		CCgNodeData* makeIfNode(	CCgNodeData* condition,
										CCgNodeData* statementtrue,
										CCgNodeData* statementfalse );
		CCgNodeData* MakeConditionalExpressionNode(	CCgNodeData* condition,
										CCgNodeData* statementtrue,
										CCgNodeData* statementfalse );
		CCgNodeData* MakeForNode(	CCgNodeData* initial,
										CCgNodeData* condition,
										CCgNodeData* loopend,
										CCgNodeData* statement,
										bool bDoWhile );
		CCgNodeData* makeFunctionDeclarationNode(CCgNodeData* identifier,
												CCgNodeData* parameterlist,
										CCgNodeData* functionbody );
		CCgNodeData* objectLiteral( CCgNodeData* Formula );
		CCgNodeData* arrayLiteral( CCgNodeData* Formula );

		CCgNodeData* exceptionHandlingClause(	CCgNodeData* bodyNode,
								CCgNodeData* catchNode,
								CCgNodeData* finallyNode );
		CCgNodeData* catchBlock( CCgNodeData* identifier,
										CCgNodeData* Body );
		CCgNodeData* finallyBlock( CCgNodeData* Body );
		CCgNodeData* throwStatement( CCgNodeData* Expression );
		CCgNodeData* labeledStatement( CCgNodeData* identifier, CCgNodeData* Statement );
		CCgNodeData* breakStatement( CCgNodeData* Expression );
		CCgNodeData* continueStatement( CCgNodeData* Expression );

		CCgNodeData* switchStatement( CCgNodeData* Expression,
										   CCgNodeData* CaseBlock );
		CCgNodeData* caseClause( CCgNodeData* Expression,
										CCgNodeData* Statement );

		//---------------------------------------------------------------------------
		//virtual functions
		//---------------------------------------------------------------------------
		CCgNodeData* variableDeclaration( CCgNodeData*, CCgNodeData* );	//Create node tree
		CCgNodeData* typedVariableDeclaration( CCgNodeData*, CCgNodeData* );	//Create node tree
		CCgNodeData* variableAssignment( CCgNodeData*, CCgNodeData* );	//Create node tree
		CCgNodeData* addOperator( CCgNodeData*, CCgNodeData* );	//Create node tree for Add
		CCgNodeData* subtractOperator( CCgNodeData*, CCgNodeData* );	//Create node tree for Sub
		CCgNodeData* multiplyOperator( CCgNodeData*, CCgNodeData* );	//Create node tree for Mul
		CCgNodeData* divisionOperator( CCgNodeData*, CCgNodeData* );	//Create node tree for Div
		CCgNodeData* reminderOperator( CCgNodeData*, CCgNodeData* );	//Create node tree for Reminder

		CCgNodeData* ifStatement( CCgNodeData*, CCgNodeData*, CCgNodeData* );	//Create Node tree for IF
		CCgNodeData* conditionalExpression( CCgNodeData*, CCgNodeData*, CCgNodeData* );	//Create Node tree for IF
		CCgNodeData* forStatement( CCgNodeData*,  CCgNodeData*, CCgNodeData*, CCgNodeData*, bool bDoWhile = false );	//Create Node tree for IF
		CCgNodeData* forInStatement( CCgNodeData* variable,
											 CCgNodeData* obj,
											 CCgNodeData* statement );
		CCgNodeData* expressionStatement( CCgNodeData* );
		CCgNodeData* withStatement( CCgNodeData*, CCgNodeData* );
		CCgNodeData* functionDeclaration( CCgNodeData* identifier,
												   CCgNodeData* ParameterList,
												   CCgNodeData* FunctionBody );
		CCgNodeData* typedFunctionDeclaration( CCgNodeData* identifier,
												   CCgNodeData* ParameterList,
												   CCgNodeData* FunctionBody,
												   CCgNodeData* ReturnValue );
	
		CCgNodeData* cmpOperator( CCgNodeData*, CCgNodeData*, CG_OPERATIONTYPE );	//Create node tree for Add
		CCgNodeData* bitwiseAndOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* bitwiseOrOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* logicalAndOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* logicalOrOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* bitwiseXorOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* shiftLeftOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* shiftRightOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* shiftRightUnsignedOperator( CCgNodeData*, CCgNodeData* );

		CCgNodeData* unaryPlusOperator( CCgNodeData* );
		CCgNodeData* unaryMinusOperator( CCgNodeData* );
		CCgNodeData* unaryIncOperator( CCgNodeData*, bool bDup  );
		CCgNodeData* unaryDecOperator( CCgNodeData*, bool bDup  );
		CCgNodeData* unaryBitwiseNotOperator( CCgNodeData* );
		CCgNodeData* unaryLogicalNotOperator( CCgNodeData* );
		CCgNodeData* unaryVoidOperator( CCgNodeData* );
		CCgNodeData* unaryDeleteOperator( CCgNodeData* );
		CCgNodeData* unaryTypeofOperator( CCgNodeData* );

		CCgNodeData* callExpression( CCgNodeData* lhs, CCgNodeData* rhs );	//Create call expression node
		CCgNodeData* returnStatement( CCgNodeData* );
		CCgNodeData* propertyAccessExpressionById( CCgNodeData*, CCgNodeData* );
		CCgNodeData* propertyAccessExpressionByExp( CCgNodeData*, CCgNodeData* );
		CCgNodeData* propertyNameAndValue( CCgNodeData*, CCgNodeData* );	//Create node tree for property init
		CCgNodeData* newOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* instanceOfOperator( CCgNodeData*, CCgNodeData* );
		CCgNodeData* inOperator( CCgNodeData*, CCgNodeData*);
		
		void endOfFile( void );
		void generateSymbolInformation( const RID rid,
										const wstring& strScopedVariableName,
										const CG_SYMBOL_FLAG Flag = CG_SYMBOL_FLAG_GLOBAL,
										const int32_t iIndex = 0 );

		//---------------------------------------------------------
		//Error report
		//---------------------------------------------------------
		void reportError( const int32_t iErrorCode );
		void reportError( const int32_t iErrorCode, const wstring& strErrorInfo );
		void reportError( const int32_t iErrorCode,
						 const uint32_t iFileId,
						 const uint32_t iLineNumber,
						 const uint32_t iColumn );
		void reportError( const int32_t iErrorCode, const wstring& strErrorInfo,
						 const uint32_t iFileId,
						 const uint32_t iLineNumber,
						 const uint32_t iColumn );
		
	private:
		//---------------------------------------------------------------------------
		//Node parse
		//---------------------------------------------------------------------------
		CCgNodeData* parseExpressionNodeTree( CCgNodeData* Formula, bool bAdjustStackEntries );		//parse & emit IL code
		CCgNodeData* parseStatementNodeTree( CCgNodeData* Formula );			//parse & emit IL code
		CCgNodeData* parseIfNode( CCgNodeData* ifnode );			//parse & emit IL code
		CCgNodeData* parseForNode( CCgNodeData* fornode, bool bDoWhile, int32_t iLoopEndLabelID = 0 );			//parse & emit IL code

		CCgNodeData* parseForInNode( CCgNodeData* fornode, int32_t iLoopEndLabelID = 0  );
		CCgNodeData* parseFunctionDeclarationNode( CCgNodeData* node, RID* ridMethod = NULL );
		CCgNodeData* parseFunctionDeclarationNodePass0( CCgNodeData* nodetree, RID* pridMethod = NULL );

		CCgNodeData* parseFunctionExpressionNode( CCgNodeData* nodetree );
		CCgNodeData* parseExceptionHandlingNode( CCgNodeData* nodetree );
		CCgNodeData* parseParameterListNodeTree( CCgNodeData* nodetree, RID ridParamList );
		CCgNodeData* parseParameterListNodeTreePass0( CCgNodeData* nodetree, RID ridParamList );

		CCgNodeData* parseExpressionStatementNode( CCgNodeData* expression );
		CCgNodeData* parseWithStatementNode( CCgNodeData* with );
		CCgNodeData* parseRetStatementNode( CCgNodeData* nodetree );
		CCgNodeData* parseobjectLiteralParameterNodeTree( CCgNodeData* nodetree, uint32_t& iNumArguments, map< RID, bool >&mapSanityCheck );
		CCgNodeData* parsearrayLiteralParameterNodeTree( CCgNodeData* nodetree, uint32_t& iNumArguments );

		CCgNodeData* parseThrowStatementNode( CCgNodeData* nodetree );
		CCgNodeData* parseSwitchStatementNode( CCgNodeData* nodetree );
		CCgNodeData* parseLabeledStatementNode( CCgNodeData* nodetree );
		CCgNodeData* parseBreakStatementNode( CCgNodeData* nodetree );
		CCgNodeData* parseContinueStatementNode( CCgNodeData* nodetree );
		CCgNodeData* parseCaseNode( CCgNodeData* nodetree );

		void parseStatementsPass0( CCgNodeData* nodetree );
		void parseStatements();
		void updateStatementTree( CCgNodeData* );
				
		//---------------------------------------------------------------------------
		//Metadata manupiration
		//---------------------------------------------------------------------------
		CMetaData m_MetaData;

		//---------------------------------------------------------------------------
		//Code gen functions	
		//---------------------------------------------------------------------------
		CCgNodeData* emitVariableDeclaration( CCgNodeData* nodetree,
											const OPERAND_TYPE type = OPERAND_UNDEFINED,
											const OPERAND_FLAG flag = OPERAND_FLAG_NONE,
											const RID ridConstraintType = 0 );	//emit CIL code
		CCgNodeData* emitTypedVariableDeclaration( CCgNodeData* nodetree );		//emit CIL code
		CCgNodeData* emitVariableAssignment( CCgNodeData* nodetree );			//emit CIL code
		CCgNodeData* emitAddOperator( CCgNodeData* nodetree );					//emit CIL code
		CCgNodeData* emitSubtractOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitMultiplyOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitDivisionOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitReminderOperator( CCgNodeData* nodetree );				//emit CIL code

		CCgNodeData* emitBitwiseAndOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitBitwiseOrOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitLogicalAndOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitLogicalOrOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitBitwiseXorOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitShiftLeftOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitShiftRightOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitShiftRightUnsignedOperator( CCgNodeData* nodetree );		//emit CIL code

		CCgNodeData* emitUnaryPlusOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitUnaryMinusOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitUnaryIncOperator( CCgNodeData* nodetree, bool bDup  );		//emit CIL code
		CCgNodeData* emitUnaryDecOperator( CCgNodeData* nodetree, bool bDup  );		//emit CIL code
		CCgNodeData* emitUnaryBitwiseNotOperator( CCgNodeData* nodetree );			//emit CIL code
		CCgNodeData* emitUnaryLogicalNotOperator( CCgNodeData* nodetree );			//emit CIL code
		CCgNodeData* emitUnaryVoidOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitUnaryDeleteOperator( CCgNodeData* nodetree );				//emit CIL code
		CCgNodeData* emitUnaryTypeofOperator( CCgNodeData* nodetree );				//emit CIL code

		CCgNodeData* emitCmpOperator( CCgNodeData* nodetree, uint32_t iOpCode );					//emit CIL code
		CCgNodeData* emitStrictCmpOperator( CCgNodeData* nodetree, uint32_t iOpCode );
		CCgNodeData* emitCallExpression( CCgNodeData* nodetree );
		CCgNodeData* emitArgumentList( CCgNodeData* nodetree, uint32_t& iNumArgumentparsed );
		CCgNodeData* emitAccessPropertyById( CCgNodeData* nodetree, CCgNodeData* parentnode );
		CCgNodeData* emitAccessPropertyByExp( CCgNodeData* nodetree, CCgNodeData* parentnode );
		CCgNodeData* emitObjectLiteral( CCgNodeData* nodetree );
		CCgNodeData* emitArrayLiteral( CCgNodeData* nodetree );
		CCgNodeData* emitConditionalExpression( CCgNodeData* conditionalnode );
		CCgNodeData* emitNewOperator( CCgNodeData* nodetree );
		CCgNodeData* emitInOperator( CCgNodeData* nodetree );
		CCgNodeData* emitInstanceOfOperator( CCgNodeData* nodetree );

		CCgNodeData* emitLoadStack( CCgNodeData* ptr );

		void emitLoadInteger( const int64_t value);
		void emitLoadBoolean( const bool value);
		void emitLoadFloat( const double value);
		void emitLoadStringObject( const RID ridString );
		void emitLoadRegexObject( CCgNodeData* nodetree );

		void emitLoadArgument( CG_SYMBOL_INFORMATION* pInfo );
		void emitStoreArgument( CG_SYMBOL_INFORMATION* pInfo );
		void emitLoadLocal( CG_SYMBOL_INFORMATION* pInfo );
		void emitStoreLocal( CG_SYMBOL_INFORMATION* pInfo );

		//---------------------------------------------------------------------------
		//Node parse helper
		//---------------------------------------------------------------------------
		/*EN Helper function to parse eval() node tree
		\return true if the node tree is parsed in the function otherwise parse it as a regular node tree
		*/
		bool parseEvalNodeTree( CCgNodeData* node );

		//---------------------------------------------------------------------------
		//Argumentlist
		//---------------------------------------------------------------------------
		void pushArgumentList( const uint32_t iParam );
		void emitArgumentList( void );
		vector< uint32_t > m_vecArgumentListStack;

		//---------------------------------------------------------------------------
		//Scope name related staff
		//---------------------------------------------------------------------------
		bool			isInGlobalScope( void );
		wstring&		getCurrentScopeName( void );
		ILFRAGMENTINFO* getCurrentScopeInformation( void );
		void			enterNewScope( wstring& strScopedFunctionName, RID ridMethod );
		void			leaveScope();
		
		int32_t	m_iCurrentEHNestLevel;	/*EN<Current Exception Handler Nesting Level*/
		wstring m_strCurrentScope;		//String that represent current scope name. Global/Function/Class scope
										//There is no block scope in ECMAScript
		bool m_bUseFinallyOps;			/*EN<Specify if it needs to use Finally ops rather than leave*/

		//---------------------------------------------------------
		//Error report
		//---------------------------------------------------------
		CErrorPool*		m_pError;
		CParser*		m_pParser;
		CLexer*			m_pLex;
		CStringLexer*	m_pStringLexer;

		//---------------------------------------------------------------------------
		// Helper
		//---------------------------------------------------------------------------
		void initializeConstantPools();
		bool isValue( CCgNodeData* object );
		bool isFloat( CCgNodeData* object );
		bool isString( CCgNodeData* object );
		void emit( uint32_t i );
		void emit( OP_CODE opcode );
		void emit( OP_CODE opcode, int8_t iParam );
		void emit( OP_CODE opcode, uint8_t iParam );
		void emit( OP_CODE opcode, int32_t iParam );
		void emit( OP_CODE opcode, uint32_t iParam );
		void emit( OP_CODE opcode, float iParam );
		void emit( OP_CODE opcode, double iParam );
		void emit( OP_CODE opcode, int64_t iParam );
		void emit( OP_CODE opcode, RID ridMethod, RID ridArg, int32_t iIndex );
		void emitArglist( OP_CODE opcode, uint8_t iParam );
		void emitArglist( OP_CODE opcode, uint32_t iParam );

		void emit( ILFRAGMENTINFO* pIL, OP_CODE opcode, int8_t iParam );
		void emit( ILFRAGMENTINFO* pIL, OP_CODE opcode, int32_t iParam );
		void UpdateILOffsetCache( void );
		void clearILOffsetCache( void );
		void adjustEvalStack( ILFRAGMENTINFO* pIL, OPCODE_TABLEENTRY* opcodeparam, int32_t iParam );
		void adjustEvalStack( int32_t i );

		CCgNodeData* parseNodeTreeSub( CCgNodeData* Formula,
										CCgNodeData* parentnode,
										bool bStackAdjustment );		//Node tree parser
		uint32_t getCurrentILOffset();
		ILFRAGMENTINFO& getCurrentILInfo() { return m_ILPool[ m_iCurrentILPoolIndex ]; }
		int32_t getILOffsetValue( int32_t iTarget, int32_t iCurrent, int32_t iSizeOfInstruction ) { return iTarget - iCurrent + iSizeOfInstruction; }

		//---------------------------------------------------------------------------
		//CodeGen management
		//---------------------------------------------------------------------------
		void checkCurrentEndianness( void);
		
		//---------------------------------------------------------------------------
		//Symbol information/Debug line information
		//---------------------------------------------------------------------------
		RID lookUpSymbolInformation( wstring& strScopedVariableName );
		RID lookUpSymbolInformation( wstring& strScopedVariableName, CG_SYMBOL_INFORMATION**ppInfo );
		RID lookUpSymbolInformationSub( wstring& strScopedVariableName, CG_SYMBOL_INFORMATION**ppInfo );
		RID lookUpSymbolInformationInCurrentScope( wstring& strScopedVariableName );
		RID lookUpSymbolInformationInCurrentScope( wstring& strScopedVariableName, CG_SYMBOL_INFORMATION**ppInfo );
		uint32_t tagTheLine();

		//---------------------------------------------------------------------------
		//Label management
		//---------------------------------------------------------------------------
		uint32_t createNewLabelID();
		uint32_t createNewLabelIDAndInsertTag();
		void insertLabelTag( uint32_t iLabelID );
		uint32_t m_iNumLabel;
		void setBranchTargetInformation( const int32_t iLabel );
		const BRANCH_TARGET_INFO& getBranchTargetInformation( int32_t iLabel );

		/*EN branch target information table*/
		vector< BRANCH_TARGET_INFO > m_vecBranchTargetInfoTable;

		//---------------------------------------------------------------------------
		//Temporary variable management
		//---------------------------------------------------------------------------
		RID reserveTemporaryVariable( CG_SYMBOL_FLAG VariableTypeToReserve );
		void releaseTemporaryVariable( RID ridToRelease );
		multimap< CG_SYMBOL_FLAG, RID> m_mapFreeTemporaryVariables;
		map< RID, CG_SYMBOL_FLAG > m_mapReservedTemporaryVariables;
		uint32_t m_iNumTmpVariable;

		//---------------------------------------------------------------------------
		//With statement objectref look up stack management
		//---------------------------------------------------------------------------
		vector< CCgNodeData* > m_WithStatementLookupStack;

		//---------------------------------------------------------------------------
		//identifier pool
		//---------------------------------------------------------------------------
		vector< int64_t > m_IntegerConstantPool;
		vector<double> m_FloatConstantPool;
		hash_map< wstring, RID > m_mapStringConsantPool;
		map< int64_t, uint32_t > m_mapIntegerConstantPool;
		map< double, uint32_t > m_mapFloatConstantPool;

		//---------------------------------------------------------------------------
		//ILPool vector
		//---------------------------------------------------------------------------
		uint32_t m_iCurrentILPoolIndex;
		V_ILFRAGMENTINFO m_ILPool;		//each function object has 1 ILFRAGMENTINFO
		ILSTACK m_ILPoolCallStack;	//manages il pool function scope

		ILFRAGMENTINFO m_ILResolvedPool;//Address resolved byte code

		//---------------------------------------------------------------------------
		//OpCodeMap for convenience
		//---------------------------------------------------------------------------
		static map< OP_CODE, OPCODE_TABLEENTRY*> m_OpcodeMapByOpcode;
		static hash_map< string, OPCODE_TABLEENTRY*> m_OpcodeMapByName;

		//---------------------------------------------------------------------------
		//Symbol info
		//---------------------------------------------------------------------------
		hash_map<wstring, CG_SYMBOL_INFORMATION> m_SymbolInfoPool;		//Symbol information
		hash_map<wstring, TYPECONSTRAINT_INFO> m_MapTypeConstraint;
		static TYPECONSTRAINT_INFO m_TypeConstraintTable[];

		//---------------------------------------------------------------------------
		//Linkage
		//---------------------------------------------------------------------------
		bool linkPass1( V_ILFRAGMENTINFO& vecILPool, ILFRAGMENTINFO& ILResolvedPool );
		bool linkPass2( ILFRAGMENTINFO& SourceILPool, ILFRAGMENTINFO& ILResolvedPool );
		bool linkFinalPass( ILFRAGMENTINFO& SourceILPool, ILFRAGMENTINFO& ILResolvedPool );
		bool resolveMethodRID();
		void adjustJumpTargetAddresses( uint32_t iAddress, int32_t iOffset );
		map< uint32_t, uint32_t > m_mapLabelID2ILAddress;
		map< uint32_t, uint32_t > m_mapAddress2LabelID;
		void putPinToCurrentAddress( uint32_t iAddress, uint32_t iTargetLabelID );
		uint8_t getCharFromILPool( ILFRAGMENTINFO& SourceILPool, uint32_t& iIndex );
		uint32_t getIntFromILPool( ILFRAGMENTINFO& SourceILPool, uint32_t& iIndex );

		bool resolveLoadArgument( ILFRAGMENTINFO* ilinfo, RID ridMethod, RID ridArglist, uint32_t iIndex );
		bool resolveStoreArgument( ILFRAGMENTINFO* ilinfo, RID ridMethod, RID ridArglist, uint32_t iIndex );
		bool resolveLoadLocal( ILFRAGMENTINFO* ilinfo, RID ridMethod, RID ridArglist, uint32_t iIndex );

		bool resolveStoreLocal( ILFRAGMENTINFO* ilinfo, RID ridMethod, RID ridArglist, uint32_t iIndex );

		//---------------------------------------------------------
		//Peephole optimizer
		//---------------------------------------------------------
		/*EN Perform PeepHole Optimizer
		Peep hole optimization is done against each ILPool WITH label info.
		With the label info, it can determine scopes.
		\param ilinfo A pointer to the IL fragment information. The fragment is modified as a result of the optimization
		\ret true if the optimization performed successfully false otherwise.
		*/
		bool performPeepholeOptimize( ILFRAGMENTINFO* ilinfo );

		/*EN PeepHole Optimizer initialization
		\ret true if the optimization initialized successfully false otherwise.
		*/
		bool initPeepholeOptimizer();

		hash_map< OP_CODE, PEEPHOLEOPTIMIZERCALLBACK > m_mapPeepholeOptimizer;

		//---------------------------------------------------------
		//Helper for peephole optimizer
		//---------------------------------------------------------
		static uint32_t getNextByteCode(ILFRAGMENT::iterator& itIn )
		{
			uint8_t c = *itIn++;
			if( c == 0xfe )
				return 0xfe00 | *itIn++;
			else
				return c;
		}
		static int32_t getIntOperand(ILFRAGMENT::iterator& itIn )
		{

			int32_t iRet = *(int32_t *)&*itIn;
			itIn += sizeof( int32_t );
			return iRet;
		}

		static int32_t optimizerConditionalBranches(ILFRAGMENT::iterator itIn, ILFRAGMENT& vecOut);
		static int32_t optimizerEliminateRedandantDup(ILFRAGMENT::iterator itIn, ILFRAGMENT& vecOut);
		static int32_t optimizerSfldIncrement(ILFRAGMENT::iterator itIn, ILFRAGMENT& vecOut);

		//---------------------------------------------------------
		//Compiler extension management
		//---------------------------------------------------------
		bool checkExtension( EXTENSION_FLAGS );
		
		//---------------------------------------------------------
		//data members
		//---------------------------------------------------------
		bool m_bInitialized;
		bool m_bResultInEvalStack;

		bool m_bRestArgsInArgList;		/*EN< Temporary flag that indicates the method uses restArgs*/

		TARGET_ENDIANNESS m_currentEndianness;
		TARGET_ENDIANNESS m_targetEndianness;

		//Break/continue related var
		bool m_bInsideSwitchStatement;
		uint32_t m_iInsideIterationStatement;
		uint32_t m_iLabelBreak;
		uint32_t m_iLabelContinue;
		uint32_t m_iLabelEndLoop;
		
		//Multipass compilation control
		bool m_bMultipass;
		CCgNodeData* m_pRootNode;
		CCgNodeData* m_pLastNode;

		//To track last 2 IL offset
		uint32_t m_iLastILOffset[ 3 ];

		//----------------------------------------------------------------------
		//MetaData RID
		//----------------------------------------------------------------------
		RID m_ridRegexObject;			//Regex object RID
		RID m_ridFunctionObject;		//Function Object RID

		RID m_ridMethodIn;
		RID m_ridMethodForIn;
		RID m_ridMethodLdPrototype;
		RID m_ridMethodStPrototype;
		RID m_ridMethodLdProperty;
		RID m_ridMethodStProperty;
		RID m_ridMethodLdPropertyByExpression;
		RID m_ridMethodStPropertyByExpression;
		RID m_ridMethodTypeOf;
		RID m_ridMethodInstanceOf;
		RID m_ridMethodStrictEqual;
		RID m_ridMethodStrictNotEqual;
		RID m_ridMethodLdobjectLiteral;
		RID m_ridMethodLdarrayLiteral;
		RID m_ridMethodFunctionCtorWithRid;
		RID m_ridMethodEval;
		RID m_ridMethodCall;
		RID m_ridMethodToNumber;

		//---------------------------------------------------------
		//compiler behaivor flags
		//---------------------------------------------------------

		//Enabled this option, the compiler assumes uninitialized value as '0'
		//e.g.
		// var a;
		// var b = a + 1;
		// now b = 1;
		bool m_bTreatUnitializedValueAsZero;
		//Enabled this option, the compiler does not allow setting to function variable
		//e.g.
		//function Hello () {};
		//Hello = 0; //Treated as an error 
		bool m_bTreatFunctionNameReadOnly;

	};

}//namespace cri
